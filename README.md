# 📌📕📚시험 공부부터 자기 계발까지, 학습 챌린지 웹사이트, 이룸

혼자 해내지 못했던 일도 함께라면 이룰 수 있어요.     
친구들과 소통하며 즐겁고 재미있게 도전하도록 만들어 주는 학습 챌린지 웹사이트,     
이룸(E-ROOM)에서 친구들과 함께 꿈을 이뤄 보세요.    

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb9Mxxb%2FbtsFzeXBd4G%2FEI5ByAgDq76hkb2VuBaWJk%2Fimg.png" width="1000">

### 이룸 둘러보기: https://eroom-challenge.com

## 📌<img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">
FE: https://github.com/Eroom-Project/Eroom-Project-FE

BE: https://github.com/Eroom-Project/Eroom-Project-BE
______________________________________

## 📌👪팀원 구성 
<table>
  <tbody>
    <tr>
      <td align="center"><a href="https://github.com/W00SIK"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXT3W0%2FbtsFz8wc2zk%2F2pGtOsJLicWbHbYM5j0cvK%2Fimg.jpg" width="200px;" height = "150px" alt=""/><br /><sub><b>FE 부팀장 : 최우식 </b></sub></a><br />
      <sub><b><a href = "https://w00sik.github.io/">기술 블로그</a></b></sub></td>
      <td align="center"><a href="https://github.com/injaehyun"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FsId6q%2FbtsFpTnJjNa%2FZk9AjKnVCMkQu1VgH2zNY1%2Fimg.png" width="200px;" height = "150px";" height = "150px" alt=""/><br />
        <sub><b>FE 팀원 : 인재현 </b></sub></a><br />
        <sub><b><a href = "https://url.kr/qvs56w">기술 블로그</a></b></sub></td>
      <td align="center"><a href="https://github.com/kuma0112"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fss156%2FbtsFzcZSKmT%2FHR43k0fwDMpbeBjR7xaTr1%2Fimg.jpg" width="200px;" height = "150px";" alt=""/><br />
        <sub><b>BE 팀장 : 이신지 </b></sub></a><br />
        <sub><b><a href = "https://kmcp.tistory.com/">기술 블로그</a></b></sub></td>
      <td align="center"><a href="https://github.com/eunchaelyu"><img src="https://github.com/Eroom-Project/Eroom-Project-BE/assets/119996957/40ca57e2-5227-43dc-ac78-d91f231eb93e" width="200px;" height = "150px";" alt=""/><br />
        <sub><b>BE 팀원 : 류은채 </b></sub></a><br />
        <sub><b><a href = "https://eunchaelyu.github.io/">기술 블로그</a></b></sub></td></td>
      <td align="center"><a href="https://github.com/mingang211"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdjCMuZ%2FbtsFpPS6ViI%2FdmOqQIuCi3lDDOXGzhYzRk%2Fimg.png" width="200px;" height = "150px";" alt=""/>
        <br /><sub><b>BE 팀원 : 민경현 </b></sub></a><br />
        <sub><b><a href = "https://a989977.tistory.com/">기술 블로그</a></b></sub></td></td>
        <td align="center"><a href=""><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmtzXY%2FbtsFvZtJ144%2FstfYE0NfKeXy7IC4A6vkmK%2Fimg.jpg" width="200px;" height="150px" alt=""/><br />
        <sub><b>디자이너 : 이주원 </b></sub></a><br />
        <sub><b><a href = "">기술 블로그</a></b></sub></td>
    </tr>
  </tbody>
</table>

______________________________________

## 📌주요 기능

## 1.😮회원가입은 간편하고 빠르게😮
<details>
<summary>회원가입/로그인/카카오 로그인 기능</summary>
<div markdown="1">
  <h3></h3>      
  
- 가입하기 전 인증 메일을 보내 멤버 여부를 확인해요    
  
- 소셜 로그인으로 간편하게 이룸의 멤버가 될 수 있어요    

<img src="https://github.com/Eroom-Project/Eroom-Project-BE/assets/119996957/74c6b0cc-2bcb-4126-a31d-0b986073ccd2" width="400"  height = "300px"> <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fl6Bnt%2FbtsFydx6MYb%2FlaD6Sm5ywO9w8gyH7zYNd0%2Fimg.png" width="280"  height = "300px">
</div>
</details>

## 2.😉목표가 같은 이들과 함께하고 싶은 당신을 위해 준비한 서비스😉
<details>
<summary>챌린지 생성/조회/검색 기능</summary>
<div markdown="1">
    <h3></h3>      
  
- 유저들이 만든 다양한 챌린지를 확인해요        
- 다양한 조건의 필터링 기능으로 원하는 챌린지를 찾아요        
- 나와 같은 목표인 챌린지에 신청할 때는 인원 제한을 확인하세요        
- 직접 챌린지를 만들면 신청자가 생길 때마다 알림이 날아가요        

<img src="https://github.com/Eroom-Project/Eroom-Project-BE/assets/119996957/0b4851fd-867c-435c-ab00-a4c2acdb8697" width="1000">
</div>
</details>

## 3.😍배움의 즐거움과 어려움을 나눌 수 있는 채팅 기능😍
<details>
<summary>실시간 채팅 기능</summary>
<div markdown="1">
    <h3></h3>      
  
- 도란도란 채팅으로 배움의 즐거움과 어려움을 실시간으로 나눠요    
- 저장된 채팅내역을 불러올 수 있어요    
- 현재 참여하고 있는 챌린지원들을 확인할 수 있어요
  
<img src ="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F56851448-83a1-471b-9a68-6a4cbe1668fb%2FUntitled.png?table=block&id=3d9a98a6-ed33-4dc4-90a3-39c845211c90&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1740&userId=58ed5a4b-1cf9-4f1b-9566-5ae5a8ec917d&cache=v2" width="1000">

https://github.com/Eroom-Project/Eroom-Project-BE/assets/119996957/17319eb6-2509-411c-b67f-8edc303c812b

</div>
</details>

## 4.😎프로필과 챌린지를 한꺼번에 관리할 수 있는 마이페이지😎
<details>
<summary>프로필 및 비밀번호 수정/참여 챌린지 조회/생성 챌린지 삭제 기능</summary>
<div markdown="1">
    <h3></h3>      
  
- 나를 보여줄 개성 있는 닉네임과 프로필 이미지를 설정해요    
- 비밀번호 수정은 현재 비밀번호를 확인해야 가능해요    
- 완주 여부, 생성 여부에 따라 챌린지를 관리해요    
- 생성한 챌린지는 이곳에서 삭제해요    

<img src ="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F9b41b1c0-7edc-414a-b025-3d9180046d02%2FUntitled.png?table=block&id=f620ec9c-02aa-4a25-a8a8-db75ef4c8402&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1740&userId=58ed5a4b-1cf9-4f1b-9566-5ae5a8ec917d&cache=v2" width="1000">

https://github.com/Eroom-Project/Eroom-Project-BE/assets/119996957/d20079f8-719e-47aa-b380-4c609cbbd8b7

</div>
</details>

## 5.😛목표에 다가가는 여정을 보여 줄 인증 페이지😛
<details>
<summary>챌린지 인증/리더의 승인/거절 기능</summary>
<div markdown="1">
    <h3></h3>      
  
- 멤버는 인증 조건에 맞춰 오늘의 목표 달성을 인증해요    
- 리더는 멤버의 인증글을 승인 혹은 거부해요    
- 인증글이 승인 및 거부되면 해당 작성자에게 알림이 날아가요    
- 알림이 날아오면 이곳에서 자신의 글을 수정, 삭제해요    
- 아직 승인받지 못한 다른 멤버의 글은 조회할 수 없어요    

<img src ="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F195db3db-78b2-4d07-ad0a-166a29d257fd%2FUntitled.png?table=block&id=00c4fec2-cfc7-4f88-ac46-2b1e5a0d567c&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1740&userId=58ed5a4b-1cf9-4f1b-9566-5ae5a8ec917d&cache=v2" width="1000">
<img src ="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fe098404f-04bb-4229-aa2b-ceb465d6a56a%2FUntitled.png?table=block&id=46422739-552e-480d-88b0-ceaecb82d149&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1740&userId=58ed5a4b-1cf9-4f1b-9566-5ae5a8ec917d&cache=v2" width="1000">
<img src ="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fd10af3df-6af6-44c0-bde8-799d96153b4e%2FUntitled.png?table=block&id=d17314a0-1caf-4272-8871-d8978e52fc6f&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1740&userId=58ed5a4b-1cf9-4f1b-9566-5ae5a8ec917d&cache=v2" width="1000">

</div>
</details>
     

______________________________________
    

## 📌BE 적용 기술

### <img src="https://img.shields.io/badge/githubactions-2088FF?style=for-the-badge&logo=githubactions&logoColor=white">

빌드, 테스트, 배포 등의 작업을 자동화 즉, 지속적 통합(CI)과 지속적 배포(CD)를 구축하는 데 유용하여 도입하였습니다.    

### <img src="https://img.shields.io/badge/docker-2496ED?style=for-the-badge&logo=docker&logoColor=white">

일관적 배포 환경을 구축하고 정기적으로 실행되는 이미지 관리 기능을 활용하여 불필요한 리소스 낭비를 줄이기 위해 도입하였습니다.    

### <img src="https://img.shields.io/badge/nginx-009639?style=for-the-badge&logo=nginx&logoColor=white">

리버스 프록시로 blue/ green 두 개의 서버 트래픽을 분산시켜 응답 시간을 최적화하기 위해 도입하였습니다.    

### <img src="https://img.shields.io/badge/redis-DC382D?style=for-the-badge&logo=redis&logoColor=white">

채팅 내용 및 Refresh token을 효율적으로 관리하는 데 적절하여 도입하였습니다.    

### <img src="https://img.shields.io/badge/websocket-25A162?style=for-the-badge&logo=websocket&logoColor=white"> , <img src="https://img.shields.io/badge/stomp-001E59?style=for-the-badge&logo=websocket&logoColor=stomp">

여러 사람이 함께 실시간으로 사용하는 채팅 기능을 구현하기 위해 도입하였습니다.    

### <img src="https://img.shields.io/badge/SSE-FFCD00?style=for-the-badge&logo=SSE&logoColor=white">

적절한 알림과 동기 부여 메시지 전송으로 사용자 편의성과 체류 시간을 늘리기 위해 도입하였습니다.    

### <img src="https://img.shields.io/badge/amazons3-569A31?style=for-the-badge&logo=amazons3&logoColor=white">
정적 파일 및 이미지를 대용량으로 저장 및 관리하기 위해 도입하였습니다.    

______________________________________

## 📌트러블 슈팅
[😇전체 트러블 슈팅 보러가기](https://www.notion.so/fac7c2d391b94c11ba2a38ee06156a92)

<details>
<summary>로그인 유무에 따른 동작 구현을 위한 dto 수정(로그인한 유저가 없는 경우)</summary>
<div markdown="1">
    <h3></h3>      
  
로그인 유무에 따라 다른 동작을 해야하고 FE에서 로그인한 member의 Id를 불러와주었으면 한다는 부탁을 받고 어떻게 구현하면 좋을지 고민을 했다.    
한 가지 방법은  @AuthenticationPrincipal UserDetailsImpl userDetails을 이용하여 서로 다른 상황을 구별하려고 했는데    
로그인한 멤버가 없을 경우 NPE가 터져 해당 방법을 사용할 수 없었다. 다른 한가지는 header에 쿠키 유무에 따라 로그인 여부를 파악하려고 했다.    
일단은 cookie 유무를 판단하여 구현하려고 하다가 userDetails에 null 값이 와도 따로 처리만 한다면 괜찮다는 글을 보아서 바로 해보았다.  

```java
@GetMapping("/challenge/{challengeId}")
public ResponseEntity<ChallengeDataResponseDto> getChallenge(@PathVariable Long challengeId,
                                                             @AuthenticationPrincipal UserDetailsImpl userDetails) {
    String loginMemberId;
    if(userDetails != null){
        loginMemberId = ""+userDetails.getMember().getMemberId();
    }else{
        loginMemberId = "No members logged in";
    }
    try {
        ChallengeDataResponseDto responseDto = challengeService.getChallenge(challengeId, loginMemberId);
        return ResponseEntity.status(HttpStatus.OK).body(responseDto);
    } catch (IllegalArgumentException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(new ChallengeDataResponseDto(null, e.getMessage(), HttpStatus.NOT_FOUND));
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ChallengeDataResponseDto(null, "오류 발생: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR));
	  }
}
```
이런 식으로 null 값을 처리해주면 오류가 발생하지 않는다는걸 알았다. 이 트러블 슈팅을 계기로 너무 어렵게 생각하지 말고 일단은 해봐야겠다는 생각을 했다.    
- 로그인한 회원에 대한 정보를 포함
![스크린샷 2024-02-19 190512](https://github.com/Eroom-Project/Eroom-Project-BE/assets/153038259/7f9ce88f-a92e-45d9-8f17-c55ff22a10e6)

- 로그인하지 않은 회원에 대한 정보를 포함
![스크린샷 2024-02-19 190533](https://github.com/Eroom-Project/Eroom-Project-BE/assets/153038259/8407fce5-38cb-4600-9987-5a0b5803ce5d)

</div>
</details>    

<details>
<summary>Redis 적용하여 이전 채팅 내역 저장 및 전송</summary>
<div markdown="1">
    <h3></h3>      
  
현 프로젝트에 채팅 내역을 저장하려면 다음과 같은 방법으로 구현해야 한다.    

1. 클라이언트에서 채팅 메시지가 생성되면 해당 메시지를 Redis의 List에 저장하고 각 채팅방은 별도의 List로 관리 한다.    
2. 채팅방의 채팅 내역이 필요한 경우 해당 채팅방의 id를 key로 설정해 List에서 채팅 내역을 조회한다.

<br/>
<br/>

**첫번째 시도 방식**    

클라이언트가 WebSocket을 통해 서버에 연결 할 때!    
클라이언트가 요청하는 **CONNECT 메시지**와 서버의 응답으로 받는 **CONNECTED 메시지**는    
**WebSocket 연결의 핸드셰이크(handshake)** 과정에서 교환된다.

이 점을 활용해 웹소켓 연결 시 클라이언트로부터 challengeId를 받아 이전 채팅내역을 불러오자.     

![Untitled](https://github.com/Eroom-Project/Eroom-Project-BE/assets/153038259/5e2fe2fe-ed6b-49a6-88f5-4b71b332e133)

1. 클라이언트가 WebSocket 연결을 시작하면 먼저 CONNECT 메시지를 서버에 보낸다.    
  이때 클라이언트는 요청하는 **CONNECT 메시지의 헤더**에 challengeId를 포함시킬 수 있다.     
  이 CONNECT 메시지를 서버가 받으면, 서버는 해당 헤더에서 challengeId를 추출할 수 있다.    
2. 서버는 클라이언트의 요청을 받아들이고 연결을 수락하는 CONNECTED 메시지를 클라이언트에게 보낸다.    
3. CONNECTED 메시지를 받는다면 클라이언트가 서버에 성공적으로 연결되었음을 나타낸다.    

```java
@EventListener
public void handleWebSocketConnectListener(SessionConnectedEvent event) {
    logger.info("Received a new web socket connection");

    // WebSocket 연결이 시작될 때 채팅 내역을 불러와 사용자에게 전송
    StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
    String challengeId = (String) headerAccessor.getSessionAttributes().get("challengeId");

    if (challengeId != null) {
        // 채팅 내역 불러오기
        Iterable<ChatMessage> chatHistory = chatRoomRepository.getChatHistory(challengeId);

        // 채팅 내역을 사용자에게 전송
        for (ChatMessage chatMessage : chatHistory) {
            messagingTemplate.convertAndSend(String.format("/sub/chat/challenge/%s", challengeId), chatMessage);
        }
    }
}
```
하지만 웹소켓이 연결되면서 challengeId를 받고 있지만 서버에서 처리하지 못하여    
이전 채팅내역을 프론트단에 전송하지 못하고 있다.    

<br/>
<br/>

**두번째 시도 방식**    


1. 웹소켓 연결이 되고 프론트단에서 ChatMessage에 JOIN type을 설정해서 서버로 보내는 시점에 이전 채팅 메시지를 프론트단으로 전송하는 로직으로 변경한다.    
2. 클라이언트가 새로고침하거나 페이지 이동 후 다시 채팅방에 들어올 때에도 프론트단에서JOIN type을 설정하여 서버에 보내기 때문에 채팅방에 들어왔을 때 해당 채팅방의 이전 메시지를 가져오도록 유도한다.    
3. 서버는 클라이언트의 요청을 받으면 해당 채팅방의 이전 메시지를 Redis에서 가져와 클라이언트에게 응답한다.    
4. 클라이언트는 서버로부터 받은 이전 메시지를 적절히 처리하여 화면에 보여준다.    

```java
// Redis에 채팅 메시지 저장
chatRoomRepository.saveChatMessage(challengeId, chatMessage);

switch (chatMessage.getType()) {
  case JOIN -> {
     System.out.println("MessagesType : JOIN");
     // 사용자가 챌린지 방에 입장할 때 ChatRoomService를 통해 currentMemberList에 추가
    chatRoomService.userJoinedRoom(challengeId, memberIdString, senderNickname, profileImageUrl);
	}
}
```

- ChatMessageService의 saveMessage메서드에서 ChatMessage 형태로 들어온 채팅 메시지는 모두 redis에 저장하고 사용자가 챌린지 방에 입장할 때 이전 채팅내역을 불러오는 로직을 추가 작성한다.    

```java
/**
 * 사용자가 채팅방에 입장했을 때 실행되는 메서드
 * @param challengeId 채팅방의 고유 식별자
 * @param memberId 사용자의 고유 식별자
 * @param senderNickname 사용자의 닉네임
 * @param profileImageUrl 사용자의 프로필 이미지 URL
 */
public void userJoinedRoom(String challengeId, String memberId, String senderNickname, String profileImageUrl) {

    List<MemberInfo> currentMemberList = challengeRoomMemberLists.get(challengeId);

    // 현재 멤버 리스트가 없는 경우 새로운 리스트 생성
    if (currentMemberList == null) {
        currentMemberList = new ArrayList<>();
        challengeRoomMemberLists.put(challengeId, currentMemberList);
    }
    // 새로운 멤버 정보 추가
    MemberInfo memberInfo = new MemberInfo(memberId, senderNickname, profileImageUrl);
    currentMemberList.add(memberInfo);

    // 해당 채팅방의 이전 대화 내용 불러오기
    List<ChatMessage> chatHistory = chatRoomRepository.getChatHistory(challengeId);

    // 채팅방의 구독자들에게 이전 대화 내용 전송
    messagingTemplate.convertAndSend(String.format("/sub/chat/challenge/%s", challengeId), chatHistory);
    // 채팅방의 구독자들에게 현재 멤버 리스트 전송
    messagingTemplate.convertAndSend(String.format("/sub/chat/challenge/%s", challengeId), currentMemberList);
}
```

- JOIN type일 때 현 참여 리스트와 이전 채팅 내역을 프론트단에 전송하는 것까지 성공했다!!    

- 하지만 n번 채팅방을 신청한 챌린지원들에게 같은 구독 주소로 응답하다보니     
구독자 중 1명만 새로고침하거나 다시 웹소켓에 재접속 해도 모든 챌린지원들에게 매번 이전 채팅 내역이 불러와지는 것이다.    

<br/>
<br/>

**해결!**    

- 이전 채팅 내역을 전송할 때는 구독 주소를 다르게 하고 memeberId를 추가하여     
채팅방에 웹소켓 연결 시도한 그 member에게만 이전 채팅 내역이 전송되도록 변경하면서 해결했다.    

```java
// 채팅방의 구독자들에게 이전 대화 내용 전송
messagingTemplate.convertAndSend(String.format("/sub/chat/challenge/%s/history/%s", challengeId, memberId), chatHistory);
// 채팅방의 구독자들에게 현재 멤버 리스트 전송
messagingTemplate.convertAndSend(String.format("/sub/chat/challenge/%s", challengeId), currentMemberList);
```
</div>
</details>

<details>
<summary>리팩토링 : Refresh Token Service 클래스 생성</summary>
<div markdown="1">
    <h3></h3>      
  
같은 이메일로 카카오 로그인과 일반 로그인을 실행했을 때 500 에러가 터졌다. 원인은 카카오 로그인의 refresh-token은 Bearer이 붙어서 저장되고,     
아닌 경우 Bearer이 떨어져서 저장되었기 때문. 따라서 같은 이메일이 두 개의 refresh-token을 가지게 되어 500에러로 이어졌다.     

**문제 해결**   

1. 먼저, 왜 카카오 refresh token에는 bearer prefix가 붙는지 확인하였다. refresh token은 JwtUtil 클래스의 createRefreshToken 메서드에서 
  만들고 저장한다.이후 KakaoService 클래스의 kakaoLogin 메서드에서 refresh token을 한번 더! 저장하는 중복되는 로직이 있는 것을 발견하였다.     
    - 여기서 ‘refreshTokenRepository.save’ 할 때는 Bearer이 없었다. 이후 Bearer이 붙은 토큰값을 반환한다.
![스크린샷 2024-02-19 오후 2 48 51](https://github.com/Eroom-Project/Eroom-Project-BE/assets/153038259/a67cdbcf-bd8c-4f82-bd70-4cb932766a7d)

    - 그런데 여기서 existingToken이 없으면, 즉 카카오 로그인을 시도하면 위에 Bearer이 붙은 String refreshToken을 사용하여 다시 한번 RefreshToken을 만든다.     
![스크린샷 2024-02-19 오후 2 49 24](https://github.com/Eroom-Project/Eroom-Project-BE/assets/153038259/195bf491-17fb-4ef5-8ab1-88e47367f5bf)

2. 따라서, 중복으로 refresh token을 저장하는 부분을 지워 주었다. 그러자 같은 로그인으로 일반 로그인을 하든,    
   카카오 로그인을 하든 refresh token이 중복 저장되지 않고 새로 토큰이 발급되어 날아갔다.     

**문제의 진짜 원인** 
- 본래 3-layer 아키텍처를 선택했을 때는, controller와 service, repository의 목적을 명확히하기 위함이었다. 따라서 repository의 의존성은 service 단에서만 가지는 게 맞다. 

- 그런데 JwtUtil 클래스를 살펴보면, 토큰을 생성할 뿐만 아니라 저장까지 한다. 이 저장 과정에서 repository의 의존성을 주입받는다. 
  다시 말해, 토큰을 저장할 수 있는 포인트가 util 클래스와 service 클래스, 두 군데가 되어 버린 것. 

- 이 점을 인식하지 못한 채 평소처럼 service에서 repository를 저장하는 로직을 짜게 되었고, 토큰 저장은 중복이 되었다. 

- JwtUtil 클래스의 목적은 무엇일까? JwtUtil 클래스는 jjwt 의존성을 이곳에 몰아넣고, 다른 곳에서 jjwt를 사용할 때 JwtUtil을 거치도록 하는 것이 그 목적이라고 생각한다.
  따라서 본래의 목적을 고려한다면 토큰 저장 메서드는 service 단에 존재해야 한다. 

- 나는 db에 Bearer이라는 반복되는 문구를 계속 저장하고 싶지 않았고, 그것 또한 비용이라고 생각하여 Bearer이 떨어진 순수 토큰값을 저장하고자 하였다.
  따라서 Bearer이 붙은 토큰을 저장하는 service단의 로직을 결국 지우자는 결정을 내렸다. 

- 이후 리팩토링할 여유가 생겨, 위의 이유를 근거로 util과 login 관련 부분을 수정하였다. 

[수정 전]

<img width="773" alt="Untitled" src="https://github.com/Eroom-Project/Eroom-Project-BE/assets/153038259/82928e34-f14c-4551-b5f6-0f8e21338036">

[수정 후]

<img width="771" alt="Untitled (1)" src="https://github.com/Eroom-Project/Eroom-Project-BE/assets/153038259/fe60144f-de24-4875-a191-56ef0e5181b7">

[RefreshTokenService 클래스]

![스크린샷 2024-03-05 오전 3 54 21](https://github.com/Eroom-Project/Eroom-Project-BE/assets/153038259/c5f32e3a-eed1-4776-bdf9-f7d6e2d27f6b)



</div>
</details>  


______________________________________

## 📌서비스 아키텍처
<img src ="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcgLQpr%2FbtsFyfo9LS9%2FN3lOoJOOw4NXeLPQgoppHk%2Fimg.png" width="1000">

______________________________________

## 📌ERD
<img src ="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fpxwbh%2FbtsFocns5l3%2F6MEqrCdrzewENq656qgKRK%2Fimg.png" width="1000">

______________________________________

## 📌기술스택

### Tech Stack
<img src="https://img.shields.io/badge/java-007396?style=for-the-badge&logo=java&logoColor=white"><img src="https://img.shields.io/badge/spring-6DB33F?style=for-the-badge&logo=spring&logoColor=white"><img src="https://img.shields.io/badge/springboot-6DB33F?style=for-the-badge&logo=springboot&logoColor=white"><img src="https://img.shields.io/badge/gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white"><img src="https://img.shields.io/badge/junit5-25A162?style=for-the-badge&logo=junit5&logoColor=white"><img src="https://img.shields.io/badge/springsecurity-6DB33F?style=for-the-badge&logo=springsecurity&logoColor=white"><img src="https://img.shields.io/badge/websocket-25A162?style=for-the-badge&logo=websocket&logoColor=white"><img src="https://img.shields.io/badge/stomp-25A162?style=for-the-badge&logo=websocket&logoColor=stomp"><img src="https://img.shields.io/badge/docker-2496ED?style=for-the-badge&logo=docker&logoColor=white"><img src="https://img.shields.io/badge/nginx-009639?style=for-the-badge&logo=nginx&logoColor=white"><img src="https://img.shields.io/badge/dockercompose-2496ED?style=for-the-badge&logo=docker&logoColor=white"><img src="https://img.shields.io/badge/amazonec2-FF9900?style=for-the-badge&logo=amazonec2&logoColor=white"><img src="https://img.shields.io/badge/jwt-000000?style=for-the-badge&logo=jsonwebtokens&logoColor=white">

### Database
<img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white"><img src="https://img.shields.io/badge/amazonrds-527FFF?style=for-the-badge&logo=amazonrds&logoColor=white"><img src="https://img.shields.io/badge/amazons3-569A31?style=for-the-badge&logo=amazons3&logoColor=white"><img src="https://img.shields.io/badge/redis-DC382D?style=for-the-badge&logo=redis&logoColor=white">


### Tool

<img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white"><img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white"><img src="https://img.shields.io/badge/githubactions-2088FF?style=for-the-badge&logo=githubactions&logoColor=white">


